###
###
###  Heart Data - Support Vector Machine
###
###
####################################################


###--- 0. Preliminary
library(tidyverse)
# load data from author's website
Heart <- read_csv(file="http://faculty.marshall.usc.edu/gareth-james/ISL/Heart.csv")
Heart

names(Heart)
#0  "X1"          index
#1  "Age"
#2  "Sex"
#3  "ChestPain"       Qualitative
#4  "RestBP"
#5  "Chol"
#6  "Fbs"
#7  "RestECG"
#8  "MaxHR"
#9  "ExAng"
#10 "Oldpeak"
#11 "Slope"
#12 "Ca"
#13 "Thal"     (Thalium stress test)   Qualitative
#14 "AHD"      Yes/No based on an angiographic test  Qualitative <-- Response


# Change class of ChestPain and Thal
Heart2 <- Heart %>% select(-"X1")
Heart2 <- Heart2 %>% mutate( ChestPain=as.factor(ChestPain),
                            Thal=as.factor(Thal),
                            AHD=as.factor(AHD))
Heart2

# Heart2 is the main format.
summary(Heart2)
sum(is.na(Heart2))    # check for NA in data
Heart2 <- Heart2 %>% na.omit()
dim(Heart2)

#  pairs(Heart2)

table(Heart2$AHD)
#  No Yes
# 160 137


cor(Heart2)  # gives error



# Pick only Numerical Colums for plotting
Heart3 <- Heart2 %>% select(-c("ChestPain", "Thal"))
Heart3 <- Heart3 %>% mutate( AHD=as.numeric(AHD=="Yes"))
Heart3 <- Heart3 %>% na.omit()
Heart3

cor(Heart3)

library(corrplot)   # install.packages("corrplot")
corrplot(cor(Heart3), method="number")
corrplot(cor(Heart3))





###--------------------------------------------------------------------
###--- 0b. Divide Dataset to Training and Testing and Set up k fold CV
Orig <- Heart2               # Entire Data set (have to be data.frame)
train.size <- 250            # num of rows for training set
test.size <-  47             # num of rows for testing set
resp.col.name <- "AHD"       # name of response column
num.folds <- 5               # k for k-fold CV
my.seed <- 7211              # give a seed

    #---
    set.seed(my.seed)
    ix = sample(1:nrow(Orig))
    Orig2 = Orig[ix, ]
    Train.set  = Orig2[1:train.size, ]
    Train.resp = Orig2[1:train.size, resp.col.name]
    Test.set   = Orig2[(train.size+1):(train.size+test.size), ]
    Test.resp  = Orig2[(train.size+1):(train.size+test.size), resp.col.name]

    # K-fold Cross Validation
    library(cvTools)     # install.packages("cvTools")
    set.seed(my.seed)
    folds = cvFolds(  nrow(Train.set),  K=num.folds  )  # k-fold CV (random assignment)

    CV.train      = list(Train.set[ folds$which!=1, ])
    CV.train.resp = list(Train.resp[folds$which!=1,1])
    CV.valid      = list(Train.set[ folds$which==1, ])
    CV.valid.resp = list(Train.resp[folds$which==1,1])

    for (k in 2:num.folds) {
      CV.train[[k]]      = Train.set[ folds$which!=k, ]
      CV.train.resp[[k]] = Train.resp[folds$which!=k,1]
      CV.valid[[k]]      = Train.set[ folds$which==k, ]
      CV.valid.resp[[k]] = Train.resp[folds$which==k,1]
    }
# Output (all data.frame):
#   Train.set      /  Train.resp
#   Test.set       /  Test.resp
#   CV.train[[k]]  /  CV.train.resp[[k]]
#   CV.valid[[k]]  /  CV.valid.resp[[k]]







###-------------------------------------------------
###--- 1. Support Vector Machine - Linear Kernel

##--- SVM on training set
library (e1071)         # install.packages("e1071")
Fit01 <- e1071::svm(AHD~., data=Train.set, kernel="linear",
                    cost=5, scale=TRUE)
summary(Fit01)


##--- c. Pick best Cost with automatic 5-fold CV
set.seed (my.seed)
Tuned01 = e1071::tune(svm, AHD~., data=Train.set, kernel ="linear",
                      ranges=list(
                          cost=c(0.01, 0.1, 1, 5, 10, 100, 1000)),
                      scale=TRUE,
                      tunecontrol=tune.control(cross=5))
summary(Tuned01)


#--- Extract the model with best cost
summary(Tuned01$best.model)

#   plot(AHD~., Tuned01$best.model, data=Train.set)


#- Pick a threshold
svm.fit   <- Tuned01$best.model   # results from CV tuning
threshold <- .7


    #------------------
    #- Training Confusion Matrix
    Train.prob0 = predict(svm.fit, Train.set, decision.values=TRUE)
    Train.prob = attributes(Train.prob0)$decision.values
    head(Train.prob) # Check col name for No/Yes or Yes/No
      #Train.pred = ifelse(Train.prob > threshold, "Yes", "No")  #-
      Train.pred = ifelse(Train.prob > threshold, "No", "Yes")
    CM.train <- caret::confusionMatrix(factor(Train.pred), factor(as.matrix(Train.resp)), positive="Yes")
    CM.train

    #- Testing Confusion Matrix
    Test.prob0 = predict(svm.fit, Test.set, decision.values=TRUE)
    Test.prob = attributes(Test.prob0)$decision.values
      #Test.pred = ifelse(Test.prob > threshold, "Yes", "No")
      Test.pred = ifelse(Test.prob > threshold, "No", "Yes")
    CM.test <- caret::confusionMatrix(factor(Test.pred), factor(as.matrix(Test.resp)), positive="Yes")
    CM.test

    #- ROC curve and AUC
    # Training
    layout(matrix(1:2,1,2))
    pROC::plot.roc(factor(as.matrix(Train.resp)), as.vector(Train.prob), levels=c("No", "Yes"))
    # point corresponding to CM.train
      abline(h=CM.train[["byClass"]][["Sensitivity"]], v=CM.train[["byClass"]][["Specificity"]], col="red")
      auc.train = pROC::auc(factor(as.matrix(Train.resp)), as.vector(Train.prob), levels=c("No", "Yes"))
      text(.2, .2, paste("AUC=",round(auc.train, 3)))
    #- Testing
    pROC::plot.roc(factor(as.matrix(Test.resp)),
                   as.vector(Test.prob), levels=c("No", "Yes"))
      # point corresponding to CM.train
      abline(h=CM.test[["byClass"]][["Sensitivity"]], v=CM.test[["byClass"]][["Specificity"]], col="red")
      auc.test = pROC::auc(factor(as.matrix(Test.resp)), as.vector(Test.prob), levels=c("No", "Yes"))
      text(.2, .2, paste("AUC=",round(auc.test, 3)))
    layout(1)
    c(auc.train, auc.test)








###-------------------------------------------------
###--- 2. Support Vector Machine - Radial Kernel

##--- SVM on training set
Fit02 <- e1071::svm(AHD~., data=Train.set, kernel="radial",
                    gamma=.5, cost=5, scale=FALSE)
summary(Fit02)


##--- c. Pick best Cost with automatic 5-fold CV
set.seed (my.seed)
Tuned02=e1071::tune(svm, AHD~., data=Train.set, kernel ="radial",
                    ranges=list(
                        gamma = 2^(-7:3),
                        cost=c(0.01, 0.1, 1, 5, 10, 100)),
                    scale=TRUE,
                    tunecontrol=tune.control(cross=5))
summary(Tuned02)


#--- Extract the model with best cost
summary(Tuned02$best.model)
    # plot(AHD~., Tuned02$best.model, data=Train.set)


#- Pick a threshold
svm.fit   <- Tuned02$best.model   # results from CV tuning
threshold <- .7


    #------------------
    #- Training Confusion Matrix
    Train.prob0 = predict(svm.fit, Train.set, decision.values=TRUE) #- high prob mean factor(1)="NO"
    Train.prob = attributes(Train.prob0)$decision.values
    head(Train.prob) # Check col name for No/Yes or Yes/No
      #Train.pred = ifelse(Train.prob > threshold, "Yes", "No")
      Train.pred = ifelse(Train.prob > threshold, "No", "Yes")
    CM.train <- caret::confusionMatrix(factor(Train.pred), factor(as.matrix(Train.resp)), positive="Yes")
    CM.train

    #- Testing Confusion Matrix
    Test.prob0 = predict(svm.fit, Test.set, decision.values=TRUE) #- high prob mean factor(1)="NO"
    Test.prob = attributes(Test.prob0)$decision.values
      #Test.pred = ifelse(Test.prob > threshold, "Yes", "No")
      Test.pred = ifelse(Test.prob > threshold, "No", "Yes")
    CM.test <- caret::confusionMatrix(factor(Test.pred), factor(as.matrix(Test.resp)), positive="Yes")
    CM.test

    #- ROC curve and AUC
    # Training
    layout(matrix(1:2,1,2))
    pROC::plot.roc(factor(as.matrix(Train.resp)), as.vector(Train.prob), levels=c("No", "Yes"))
    # point corresponding to CM.train
      abline(h=CM.train[["byClass"]][["Sensitivity"]], v=CM.train[["byClass"]][["Specificity"]], col="red")
      auc.train = pROC::auc(factor(as.matrix(Train.resp)), as.vector(Train.prob), levels=c("No", "Yes"))
      text(.2, .2, paste("AUC=",round(auc.train, 3)))
    #- Testing
    pROC::plot.roc(factor(as.matrix(Test.resp)),
                   as.vector(Test.prob), levels=c("No", "Yes"))
      # point corresponding to CM.train
      abline(h=CM.test[["byClass"]][["Sensitivity"]], v=CM.test[["byClass"]][["Specificity"]], col="red")
      auc.test = pROC::auc(factor(as.matrix(Test.resp)), as.vector(Test.prob), levels=c("No", "Yes"))
      text(.2, .2, paste("AUC=",round(auc.test, 3)))
    layout(1)
    c(auc.train, auc.test)










###-------------------------------------------------
###--- 3. Support Vector Machine - Polynomial Kernel

##--- Pick best Cost with automatic 5-fold CV
set.seed (my.seed)
Tuned03=e1071::tune(svm, AHD~., data=Train.set, kernel ="polynomial",
                    ranges=list(
                        degree = 2^(-1:3),
                        gamma = 2^(2:5),
                        coef0=c(0, 1),
                        cost=c(0.01, 0.1, 1, 5, 10)),
                    scale=TRUE,
                    tunecontrol=tune.control(cross=5))
summary(Tuned03)


#--- Extract the model with best cost
summary(Tuned03$best.model)

    # plot(AHD~., Tuned02$best.model, data=Train.set)


#- Pick a threshold
svm.fit   <- Tuned03$best.model   # results from CV tuning
threshold <- .7


    #------------------
    #- Training Confusion Matrix
    Train.prob0 = predict(svm.fit, Train.set, decision.values=TRUE) #- high prob mean factor(1)="NO"
    Train.prob = attributes(Train.prob0)$decision.values
    head(Train.prob) # Check col name for No/Yes or Yes/No
    Train.pred = ifelse(Train.prob > threshold, "No", "Yes")
    CM.train <- caret::confusionMatrix(factor(Train.pred), factor(as.matrix(Train.resp)), positive="Yes")
    CM.train

    #- Testing Confusion Matrix
    Test.prob0 = predict(svm.fit, Test.set, decision.values=TRUE) #- high prob mean factor(1)="NO"
    Test.prob = attributes(Test.prob0)$decision.values
    Test.pred = ifelse(Test.prob > threshold, "No", "Yes")
    CM.test <- caret::confusionMatrix(factor(Test.pred), factor(as.matrix(Test.resp)), positive="Yes")
    CM.test

    #- ROC curve and AUC
    # Training
    layout(matrix(1:2,1,2))
    pROC::plot.roc(factor(as.matrix(Train.resp)), as.vector(Train.prob), levels=c("No", "Yes"))
    # point corresponding to CM.train
      abline(h=CM.train[["byClass"]][["Sensitivity"]], v=CM.train[["byClass"]][["Specificity"]], col="red")
      auc.train = pROC::auc(factor(as.matrix(Train.resp)), as.vector(Train.prob), levels=c("No", "Yes"))
      text(.2, .2, paste("AUC=",round(auc.train, 3)))
    #- Testing
    pROC::plot.roc(factor(as.matrix(Test.resp)),
                   as.vector(Test.prob), levels=c("No", "Yes"))
      # point corresponding to CM.train
      abline(h=CM.test[["byClass"]][["Sensitivity"]], v=CM.test[["byClass"]][["Specificity"]], col="red")
      auc.test = pROC::auc(factor(as.matrix(Test.resp)), as.vector(Test.prob), levels=c("No", "Yes"))
      text(.2, .2, paste("AUC=",round(auc.test, 3)))
    layout(1)
    c(auc.train, auc.test)









###-----------------------------------------------------------
###--- Threshold Picker



#cost.list = c(0,0,3,1)/4           # order of (TP, TN, FP, FN)
#cost.list = c(0,0,2,1)/3           # order of (TP, TN, FP, FN)
#cost.list = c(0,0,1,1)/2           # order of (TP, TN, FP, FN)
#cost.list = c(0,0,1,2)/3           # order of (TP, TN, FP, FN)
cost.list = c(0,0,1,3)/4           # order of (TP, TN, FP, FN)


threshold.list = seq(.01,.99,.01)    # grid for threshold


#- Pick a model
svm.fit   <- Tuned02$best.model
Test.prob0 = predict(svm.fit, Test.set, decision.values=TRUE)
Test.prob = attributes(Test.prob0)$decision.values
head(Test.pred) # Check col name for No/Yes or Yes/No


library(caret)      # for confusionMatrix
cost=0
for (i in 1:length(threshold.list)){

    threshold = threshold.list[i]

    #- Check the training set accuracy
    Test.pred  = ifelse(Test.prob  > threshold, "Yes", "No")
    CM.test  <- confusionMatrix(factor(Test.pred),
                                factor(as.matrix(Test.resp)),
                                positive="Yes")
    TP = CM.test$table[2,2]   # True  Pos
    TN = CM.test$table[1,1]   # True  Neg
    FP = CM.test$table[2,1]   # False Pos
    FN = CM.test$table[1,2]   # False Neg

    cost[i] = sum(c(TP, TN, FP, FN) * cost.list)
}
plot(threshold.list, cost, xlab="threshold")

cost.list
which.min(cost)
min(cost)
threshold.list[which.min(cost)]
